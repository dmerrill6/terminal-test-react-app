"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const api_service_1 = require("../../shared/api/api-service");
const environment_types_1 = require("../../shared/enums/environment-types");
const log_level_1 = require("../../shared/enums/log-level");
const utils_1 = require("../../shared/utils");
const enums_1 = require("../enums");
const source_types_1 = require("../enums/source-types");
class TerminalBaseProvider {
    constructor(_baseOptions, _providerOptions) {
        this._baseOptions = _baseOptions;
        this._providerOptions = _providerOptions;
        this.connected = false;
        if (!this._baseOptions.apiKey) {
            throw new Error('You must supply an API key to the `Provider`');
        }
        if (!this._baseOptions.source) {
            throw new Error('You must supply a source to the `Provider`');
        }
        if (this._baseOptions.environment &&
            !environment_types_1.EnvironmentTypes[this._baseOptions.environment]) {
            throw new Error('You must supply a valid environment type of `dev`, `staging` or `live`. Will default to live if no environment is passed in');
        }
        this._baseProviderOptions = {
            source: this._baseOptions.source,
            apiKey: this._baseOptions.apiKey,
            projectId: this._baseOptions.projectId,
            logLevel: this._baseOptions.logLevel === undefined
                ? log_level_1.LogLevel.Error
                : this._baseOptions.logLevel,
            environment: this._baseOptions.environment || environment_types_1.EnvironmentTypes.live
        };
        this._apiService = new api_service_1.ApiService(this._baseProviderOptions.apiKey, this._baseProviderOptions.environment);
    }
    /**
     * Send async jsonrpc method interceptor (backwards compatibility)
     * @param method The jsonrpc method
     * @param parameters The parameters
     */
    sendAsync(payload, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = payload;
            let errorMessage;
            const responseTimeMs = [];
            try {
                // if `response` is array then its a bulk send
                if (Array.isArray(response)) {
                    const results = [];
                    for (let g = 0; g < response.length; g++) {
                        const start = new Date().getTime();
                        const result = yield this.send(response[g].method, response[g].params, true);
                        const end = new Date().getTime();
                        response[g].result = result;
                        results.push(result);
                        responseTimeMs.push(end - start);
                    }
                    callback(null, results);
                }
                else {
                    const start = new Date().getTime();
                    const result = yield this.send(response.method, response.params, true);
                    const end = new Date().getTime();
                    response.result = result;
                    responseTimeMs.push(end - start);
                    if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                        // if its MM then we need to go just pass in the result as on the
                        // 0.2.x version it has a different interface
                        callback(null, result);
                    }
                    else {
                        callback(null, response);
                    }
                }
            }
            catch (error) {
                // handle MM error stack as it provides much better message errors
                if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                    errorMessage = this.buildUpMetaMaskErrorMessage(error);
                }
                else if (error.message) {
                    errorMessage = error.message;
                }
                else {
                    errorMessage = error;
                }
                callback(error, null);
            }
            // save the log last so the `callback` can be set so web3 can carry on
            try {
                if (!errorMessage) {
                    // if `response` is array then its a bulk send
                    if (Array.isArray(response)) {
                        for (let l = 0; l < response.length; l++) {
                            if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                                this.saveToLogs(response[l], response[l].result.result, responseTimeMs[l]);
                            }
                            else {
                                this.saveToLogs(response[l], response[l].result, responseTimeMs[l]);
                            }
                        }
                    }
                    else {
                        if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                            // the result itself is in `.result.result` as again its using a own 0.2.x interface
                            this.saveToLogs(response, response.result.result, responseTimeMs[0]);
                        }
                        else {
                            this.saveToLogs(response, response.result, responseTimeMs[0]);
                        }
                    }
                }
                else {
                    // if its a batch request using `0.2.x` web3 instance
                    if (Array.isArray(response)) {
                        for (let l = 0; l < response.length; l++) {
                            this.saveToLogs(response[l], errorMessage, responseTimeMs[l], true);
                        }
                    }
                    else {
                        this.saveToLogs(response, errorMessage, responseTimeMs[0], true);
                    }
                }
            }
            catch (error) {
                // tslint:disable-next-line: no-console
                console.error(
                // tslint:disable-next-line: max-line-length
                `Could not save log, something in your terminal setup is incorrect or the log server is currently down ${error}`);
            }
        });
    }
    /**
     * Send jsonrpc method interceptor
     * @param method The jsonrpc method (in some old cases it may send the `ISendAsyncPayload` interface)
     * @param parameters The parameters
     * @param _fromSendAsync This tells us if send async did the call which means `saveToLogs` has already been called.
     *                       web3 have different behaviour between 1.0 and 2.0 so have to handle some edge cases here.
     */
    send(method, parameters = [], _fromSendAsync = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // handle 0.20.x cases with metamask where they hit send straight away
            // without going through `sendAsync`
            // this is for bespoke stuff like `sendBulk` but we need to handle it
            if (typeof method === 'object' && typeof method.method === 'string') {
                parameters = method.params || [];
                method = method.method;
            }
            if (!method || typeof method !== 'string') {
                throw new Error('Method is not a valid string');
            }
            if (!(parameters instanceof Array)) {
                throw new Error('Params is not a valid array');
            }
            if (!this._provider) {
                throw new Error('Provider is not set');
            }
            // use the provider which set in constructor to call the node
            return yield this._provider.send(method, parameters);
        });
    }
    /**
     * Send batch will just send 1 at the time for now
     * @param methods The method
     * @param moduleInstance The module instances
     */
    sendBatch(methods, moduleInstance) {
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            const result = yield this._provider.sendBatch(methods, moduleInstance);
            const payloads = [];
            for (let i = 0; i < methods.length; i++) {
                const rpcMethodResponse = result[i];
                payloads.push({
                    payload: {
                        id: rpcMethodResponse.id,
                        jsonrpc: rpcMethodResponse.jsonrpc,
                        method: methods[i].rpcMethod,
                        params: methods[i].parameters,
                        result: rpcMethodResponse.result || rpcMethodResponse.error
                    },
                    isError: rpcMethodResponse.error !== undefined
                });
            }
            this.saveBulkToLogs(payloads);
            return result;
        });
    }
    /**
     * Get chain id
     */
    getChainId(provider) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._chainId) {
                return this._chainId;
            }
            try {
                const netVersion = yield provider.send('net_version', []);
                if (netVersion) {
                    if (typeof netVersion === 'string') {
                        return netVersion;
                    }
                    else {
                        return netVersion.result;
                    }
                }
                return 'unknown';
            }
            catch (error) {
                // mute error and state unknown
            }
            return 'unknown';
        });
    }
    /**
     * Save bulk to logs
     * @param bulkPayloads The bulk payload
     */
    saveBulkToLogs(bulkPayloads) {
        for (let i = 0; i < bulkPayloads.length; i++) {
            const info = bulkPayloads[i];
            this.saveToLogs(info.payload, info.payload.result, undefined, info.isError);
        }
    }
    /**
     * Save to logs
     * @param payload The payload
     * @param result The result
     * @param isError If its a error
     */
    saveToLogs(payload, result, responseTimeMs, isError = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!Array.isArray(payload.params)) {
                payload.params = [payload.params];
            }
            if (Array.isArray(payload.params)) {
                for (let i = 0; i < payload.params.length; i++) {
                    if (typeof payload.params[i] === 'object') {
                        payload.params[i] = JSON.stringify(payload.params[i]);
                    }
                }
            }
            let chainId = this._chainId;
            if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
                chainId = this.getMetaMaskChainId();
            }
            let headers = [];
            if (this._providerOptions && this._providerOptions.headers) {
                headers = this._providerOptions.headers;
            }
            const logRequest = {
                id: payload.id,
                jsonrpc: payload.jsonrpc,
                nodeUrl: this.getHost(),
                method: payload.method,
                parameters: payload.params || [],
                result: this.parseJsonRPCResult(result),
                source: this._baseProviderOptions.source,
                isError,
                responseTimeMs,
                chainId,
                headers: JSON.stringify(headers),
                projectId: this._baseProviderOptions.projectId
            };
            yield this._apiService.saveToLogs(logRequest);
        });
    }
    /**
     * Parse the jsonrpc result
     * @param result The jsonrpc result
     */
    parseJsonRPCResult(result) {
        if (!result) {
            return null;
        }
        if (typeof result === 'string') {
            return result;
        }
        if (typeof result === 'object') {
            const deepResultClone = utils_1.Utils.deepClone(result);
            return JSON.stringify(deepResultClone);
        }
        return result.toString();
    }
    /**
     * Set the chain id
     */
    setChainId(provider, 
    // tslint:disable-next-line: no-unnecessary-initializer
    web3Version = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            this._chainId = yield this.getChainId(provider);
            // if its web3 1 kill this provider as we had to used
            // web3 2.0 so we can get chainId
            if (web3Version === enums_1.Web3Versions.one && provider.connection) {
                provider.connection.close();
            }
        });
    }
    /**
     * Get the host
     */
    getHost() {
        if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
            // MetaMask do not expose node url so just return unknown
            return 'unknown';
        }
        if (!this.host) {
            throw new Error('You need to set the host in your provider');
        }
        return this.host;
    }
    /**
     * Get metamask chain id
     */
    getMetaMaskChainId() {
        if (this._baseProviderOptions.source === source_types_1.SourceType.MetaMask) {
            const _window = utils_1.Utils.getWindow();
            if (_window && _window.ethereum && _window.ethereum.networkVersion) {
                return _window.ethereum.networkVersion;
            }
        }
        return 'unknown';
    }
    /**
     * Build up metamask error message for the logs
     * @param error The error
     */
    buildUpMetaMaskErrorMessage(error) {
        if (!error) {
            return 'MetaMask error occurred but did not emit any useful errors';
        }
        if (typeof error === 'string') {
            return error;
        }
        return `code: ${error.code}, message: ${error.message}, stack: ${error.stack}`;
    }
}
exports.TerminalBaseProvider = TerminalBaseProvider;
