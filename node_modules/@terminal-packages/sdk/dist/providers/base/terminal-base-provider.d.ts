import { AbstractWeb3Module } from 'web3-core';
import { AbstractMethod } from 'web3-core-method';
import { HttpProvider, WebsocketProvider, HttpProviderOptions } from 'web3-providers';
import { Web3Versions } from '../enums';
import { IBaseProviderOptions } from './models/ibase-provider-options';
import { IBulkSaveToLogs } from './models/ibulk-save-to-logs';
import { ISendAsyncPayload } from './models/isend-async-payload';
import { IWebsocketProviderOptions } from '../websockets/models/iwebsocket-provider-options';
export declare class TerminalBaseProvider {
    private _baseOptions;
    private _providerOptions?;
    connected: boolean;
    host: string;
    protected _provider: HttpProvider | WebsocketProvider;
    protected _chainId: string | undefined;
    private _apiService;
    private _baseProviderOptions;
    constructor(_baseOptions: IBaseProviderOptions, _providerOptions?: HttpProviderOptions | IWebsocketProviderOptions | undefined);
    /**
     * Send async jsonrpc method interceptor (backwards compatibility)
     * @param method The jsonrpc method
     * @param parameters The parameters
     */
    sendAsync(payload: ISendAsyncPayload | ISendAsyncPayload[], callback: (error: Error | null, result: any) => void): Promise<void>;
    /**
     * Send jsonrpc method interceptor
     * @param method The jsonrpc method (in some old cases it may send the `ISendAsyncPayload` interface)
     * @param parameters The parameters
     * @param _fromSendAsync This tells us if send async did the call which means `saveToLogs` has already been called.
     *                       web3 have different behaviour between 1.0 and 2.0 so have to handle some edge cases here.
     */
    send(method: string | ISendAsyncPayload, parameters?: any[], _fromSendAsync?: boolean): Promise<any>;
    /**
     * Send batch will just send 1 at the time for now
     * @param methods The method
     * @param moduleInstance The module instances
     */
    sendBatch(methods: AbstractMethod[], moduleInstance: AbstractWeb3Module): Promise<any[]>;
    /**
     * Get chain id
     */
    protected getChainId(provider: any): Promise<string>;
    /**
     * Save bulk to logs
     * @param bulkPayloads The bulk payload
     */
    protected saveBulkToLogs(bulkPayloads: IBulkSaveToLogs[]): void;
    /**
     * Save to logs
     * @param payload The payload
     * @param result The result
     * @param isError If its a error
     */
    protected saveToLogs(payload: ISendAsyncPayload, result: any, responseTimeMs: number | undefined, isError?: boolean): Promise<void>;
    /**
     * Parse the jsonrpc result
     * @param result The jsonrpc result
     */
    protected parseJsonRPCResult(result: any): string | null;
    /**
     * Set the chain id
     */
    protected setChainId(provider: any, web3Version?: Web3Versions | undefined): Promise<void>;
    /**
     * Get the host
     */
    private getHost;
    /**
     * Get metamask chain id
     */
    private getMetaMaskChainId;
    /**
     * Build up metamask error message for the logs
     * @param error The error
     */
    private buildUpMetaMaskErrorMessage;
}
